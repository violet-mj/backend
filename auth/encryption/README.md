# Crypto
---

> 암호화?

- 단방향 암호화
  - 복호화 할 수 없는 암호화
- 양뱡향 암호화
  - 대칭형 암호
    - 동일 키를 가지는 암호화
  - 비대칭형 암호화
    - 서로 다른 키를 가지는 암호화


> 대칭형 암호화

  - 동일키를 이용하여 암호화와 복호화를 진행함

<img src="data:image/png;base64,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">

<br/>

> Hmac


- MAC은 메시지 인증 코드 생성 방법입니다. => 단방향 암호화 기법
  - 송신자의 경우 수신자와 미리 공유된 키를 가지고 메시지 해쉬값을 만들어 냅니다. 이 해쉬값이 MAC입니다. 이것을 메시지와 함께 보냅니다.
  - 수신자의 경우 송신자로 부터 받은 MAC과 메시지를 키와 함께 해쉬값을 만든 후 비교합니다, 같으면 송신자로 온 것이 확인이 되고 아니면 변경이 되었거나 임의로 보낸 것이라 판단 할 수 있습니다. 
  - 해쉬와 다른점은 HMAC은 비밀번호를 해쉬 함수에 넣음으로써 인증의 기능도 한다는 것입니다.
``` javascript
const crypto = require('crypto')
const secret = 'abcdefg'
const hash = crypto.createHmac('sha256', secret)
                   .update('Welcome to minjun')
                   .digest('hex')

console.log(hash)

```

- 단방향 암호화의 경우 같은 해쉬 함수를 사용하고 같은 값이 들어가면 같은 암호화된 값이 나온다.

> Cipher

- Cipher의 경우 암호화와 복호화가 모두 가능한 양방향 암호화 기법입니다.

### use NODE

- node에서 `crypto.createCipheriv(algorithm, key, iv)`를 이용한 암호화와 `crypto.createDecipheriv(algorithm, key, iv)`를 이용한 복호화 모듈을 이용한다


- iv(initialize vector)는 난수나 가상난수를 쓰기 때문에 예측 불가능하며 독특하다. 난수화는 의미론적의 보안을 이루기위해 중요하다. 

| Algorithm | Key | iv |
| ----------| ----| ---|
| aes128    | 16byte | 16byte |
| aes-128-cbc | 16byte | 16byte |
| aes192 | 24byte | 16byte |
| aes256 | 32byte | 16byte

``` typescript
import crypto from 'crypto'

let algorithm = 'aes-256-ctr'
const key = Buffer.alloc(32)
key.fill(0)
const iv = Buffer.alloc(16)
iv.fill(0)

// text를  암호화한다.
const encrypt = (text: string): string => {
  const cipher: crypto.Cipher = crypto.createCipheriv(algorithm, key, iv)
  let crypted: string = cipher.update(text, 'utf-8', 'base64')
  crypted += cipher.final('base64')
  return crypted
}

// text를 복호화한다.
const decrypt = (text: string): string => {
  const cipher: crypto.Decipher = crypto.createDecipheriv(algorithm, key, iv)
  let crypted: string = cipher.update(text, 'base64', 'utf-8')
  crypted += cipher.final('utf-8')
  return crypted
}

let encrypted = encrypt('mypassword')
console.log(encrypted)
let decrypted = decrypt(encrypted)
console.log(decrypted)

```


> etc

- ### Buffer란?
  - buffer는 raw 바이너리 데이터를 저장할 수 있는 특수한 유형의 객체다. 버퍼는 일반적으로 컴포터에 할당된 메로리 청크, 일반적으로 RAM을 나타낸다. 일단 버퍼크기를 설정하게 되면, 이후에는 변경할 수 없다.

  - 버퍼는 바이트를 저장하는 단위이다.

   ```javascript
    <Buffer 79 63 65 66 66 6f 72 74>
   ```

  - 비트는 0,1로 나타내지만 이 경우 16진수로 나타내 압축 했을 뿐이지 사실 풀어내면 0,1로 나타낸 것과 같다.
  -    


- ### Base64란?
  - 8비트 이진데이터를 9비트 이진데이터를 문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들로 이루어진 일련의 문자열로 바꾸는 인코딩 방식

  - #### definition
    - base64로 변환하는 바업은 연속된 8비트의 데이터를 6비트씩 잘라 그 값을 읽어 색인표 해당하는 값을 출력한다.


``` txt
Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.
```

base64 encode를 통해 아래와 같이 변환된다.

```
TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0
aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1
c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0
aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl
LCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=
```

<string> 예를 들어 Man 이라는 글자는 다음과 같이 변환된다. </strong>
<table class="wikitable">
<tbody><tr>
<td>Text content
</td>
<td colspan="8" align="center"><b>M</b>
</td>
<td colspan="8" align="center"><b>a</b>
</td>
<td colspan="8" align="center"><b>n</b>
</td></tr>
<tr>
<td>ASCII
</td>
<td colspan="8" align="center">77
</td>
<td colspan="8" align="center">97
</td>
<td colspan="8" align="center">110
</td></tr>
<tr>
<td>Bit pattern</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0
</td></tr>
<tr>
<td>Index
</td>
<td colspan="6" align="center">19
</td>
<td colspan="6" align="center">22
</td>
<td colspan="6" align="center">5
</td>
<td colspan="6" align="center">46
</td></tr>
<tr>
<td>Base64-Encoded
</td>
<td colspan="6" align="center"><b>T</b>
</td>
<td colspan="6" align="center"><b>W</b>
</td>
<td colspan="6" align="center"><b>F</b>
</td>
<td colspan="6" align="center"><b>u</b>
</td></tr></tbody></table>


## TypedArray

- typedarray는 이진 데이터 buffer의 array-like 형태로 표현된다. 

``` javascript
const typedArray = new Int8Array(8);
typedArray1[0] = 32
```

<table class="standard-table">
 <tbody>
  <tr>
   <td class="header">유형</td>
   <td class="header">크기 (바이트)</td>
   <td class="header">설명</td>
   <td class="header">Web IDL 형</td>
   <td class="header">해당 C 형</td>
  </tr>
  <tr>
   <td><a href="/ko/docs/Web/JavaScript/Reference/Global_Objects/Int8Array"><code>Int8Array</code></a></td>
   <td>1</td>
   <td>8비트 2의 보수 형식 부호 있는 정수</td>
   <td><code>byte</code></td>
   <td><code>int8_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Uint8Array</code></a></td>
   <td>1</td>
   <td>8비트 부호 없는 정수</td>
   <td><code>octet</code></td>
   <td><code>uint8_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Uint8ClampedArray</code></a></td>
   <td>1</td>
   <td>8비트 부호 없는 정수 (단속됨)</td>
   <td><code>octet</code></td>
   <td><code>uint8_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Int16Array</code></a></td>
   <td>2</td>
   <td>16비트 2의 보수 형식 부호 있는 정수</td>
   <td><code>short</code></td>
   <td><code>int16_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Uint16Array</code></a></td>
   <td>2</td>
   <td>16비트 부호 없는 정수</td>
   <td><code>unsigned short</code></td>
   <td><code>uint16_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Int32Array</code></a></td>
   <td>4</td>
   <td>32비트 2의 보수 형식 부호 있는 정수</td>
   <td><code>long</code></td>
   <td><code>int32_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Uint32Array</code></a></td>
   <td>4</td>
   <td>32비트 부호 없는 정수</td>
   <td><code>unsigned long</code></td>
   <td><code>uint32_t</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Float32Array</code></a></td>
   <td>4</td>
   <td>32비트 IEEE 부동 소수점 수</td>
   <td><code>unrestricted float</code></td>
   <td><code>float</code></td>
  </tr>
  <tr>
   <td><a class="page-not-created" title="The documentation about this has not yet been written; please consider contributing!"><code>Float64Array</code></a></td>
   <td>8</td>
   <td>64비트 IEEE 부동 소수점 수</td>
   <td><code>unrestricted double</code></td>
   <td><code>double</code></td>
  </tr>
 </tbody>
</table>

## Bcrypt

- **Bcrypt**는 암호 해싱 함수로 Blowfish 암호를 기반으로 만들어 졌다. bcrypt는 rainbow table attack에 대비하여 salt를 추가 시켰으며 bcrypt는 적응형 함수이다 반복 카운터는 암호문을 만드는데 더 오래 걸리지만 컴퓨터 연산 능력이 증가하더라도 브루트 포스 공격에 대응할 수 있다.

  > Blowfish는 